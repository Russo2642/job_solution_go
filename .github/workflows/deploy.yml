name: Deploy JobSolution

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/job_solution:latest

      - name: Prepare deployment files
        run: |
          # Создаем временную директорию для файлов деплоя
          mkdir -p deploy_files
          
          # Копируем docker-compose.yml
          cp docker-compose.yml deploy_files/
          
          # Копируем nginx.conf если он есть
          if [ -f "nginx.conf" ]; then
            cp nginx.conf deploy_files/
          fi
          
          # Создаем директории для миграций
          mkdir -p deploy_files/internal/db/migrations
          
          # Копируем файлы миграций
          cp -r internal/db/migrations/* deploy_files/internal/db/migrations/
          
          # Для проверки выводим список файлов
          echo "Файлы для деплоя:"
          ls -la deploy_files/
          ls -la deploy_files/internal/db/migrations/

      - name: Copy deployment files to server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: "deploy_files/*"
          target: "/home/${{ secrets.SERVER_USER }}/temp_deploy"
          strip_components: 1

      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            set -e

            cd ~
            
            # Создаём директории если они не существуют
            mkdir -p internal/db/migrations
            mkdir -p certbot/conf certbot/www
            
            # Копируем файлы из временной директории деплоя
            if [ -d ~/temp_deploy ]; then
              # Копируем docker-compose.yml и nginx.conf
              cp ~/temp_deploy/docker-compose.yml ./docker-compose.yml
              if [ -f ~/temp_deploy/nginx.conf ]; then
                cp ~/temp_deploy/nginx.conf ./nginx.conf
              fi
              
              # Копируем миграции с правильными правами
              if [ -d ~/temp_deploy/internal/db/migrations ]; then
                echo "Копирование миграций..."
                sudo cp -r ~/temp_deploy/internal/db/migrations/* ./internal/db/migrations/
                # Настраиваем права доступа
                sudo chmod -R 777 ./internal/db
                sudo chown -R $(whoami):$(whoami) ./internal
              else
                echo "ПРЕДУПРЕЖДЕНИЕ: Миграции не найдены в директории temp_deploy!"
                ls -la ~/temp_deploy
              fi
              
              # Удаляем временную директорию
              rm -rf ~/temp_deploy
            else
              echo "ОШИБКА: Директория temp_deploy не найдена!"
              exit 1
            fi

            # Создание .env файла
            cat > .env <<EOL
            # Настройки сервера
            SERVER_PORT=${{ secrets.SERVER_PORT }}
            SERVER_MODE=${{ secrets.SERVER_MODE }}

            # PostgreSQL
            POSTGRES_HOST=${{ secrets.POSTGRES_HOST }}
            POSTGRES_PORT=${{ secrets.POSTGRES_PORT }}
            POSTGRES_USER=${{ secrets.POSTGRES_USER }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB }}
            POSTGRES_SSLMODE=${{ secrets.POSTGRES_SSLMODE }}
            POSTGRES_MAX_OPEN_CONNS=${{ secrets.POSTGRES_MAX_OPEN_CONNS }}
            POSTGRES_MAX_IDLE_CONNS=${{ secrets.POSTGRES_MAX_IDLE_CONNS }}
            POSTGRES_CONN_MAX_LIFETIME=${{ secrets.POSTGRES_CONN_MAX_LIFETIME }}

            # JWT
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}
            JWT_REFRESH_EXPIRES_IN=${{ secrets.JWT_REFRESH_EXPIRES_IN }}

            # Безопасность
            PASSWORD_SALT=${{ secrets.PASSWORD_SALT }}

            # Лимиты запросов
            RATE_LIMIT_REQUESTS=${{ secrets.RATE_LIMIT_REQUESTS }}
            RATE_LIMIT_DURATION=${{ secrets.RATE_LIMIT_DURATION }}

            # Docker Hub
            DOCKER_USERNAME=${{ secrets.DOCKER_USERNAME }}
            EOL

            # Проверка наличия директории с миграциями
            if [ ! -d "internal/db/migrations" ] || [ -z "$(ls -A internal/db/migrations)" ]; then
              echo "ПРЕДУПРЕЖДЕНИЕ: Директория миграций пуста или не существует!"
              echo "Попытка создать структуру..."
              mkdir -p internal/db/migrations
            else
              echo "Директория миграций существует и содержит файлы:"
              ls -la internal/db/migrations
            fi

            # Принудительная остановка всех старых контейнеров
            echo "Остановка всех старых контейнеров..."
            docker-compose down || true
            
            # Проверка на наличие "зависших" контейнеров и их удаление
            if docker ps -a | grep "job_solution_"; then
              echo "Обнаружены старые контейнеры, удаляем их принудительно..."
              docker ps -a | grep "job_solution_" | awk '{print $1}' | xargs -r docker rm -f
            fi
            
            # Загрузка образов
            echo "Загрузка новых образов..."
            docker-compose pull

            # Запуск новых контейнеров
            echo "Запуск новых контейнеров..."
            docker-compose up -d

            # Очистка неиспользуемых образов
            docker image prune -af
            
            # Отображение статуса
            echo "Статус контейнеров:"
            docker-compose ps
